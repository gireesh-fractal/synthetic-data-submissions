import numpy as np
import mpmath
import matplotlib as mpl
from matplotlib import pyplot as plt
from data_generation.interplanetary_distance import (
    generate_distances_for_years,
    generate_3_planet_distances_for_years
)
from data_generation.constants import planet_data

# https://www.digitalocean.ie/Data/DownloadTideData

mode = 'Data' # options: 'Data', 'Math.Bessel', 'Math.Zeta'
data_type = 'planets_3_body'

#--- read data

if mode == 'Data':

    # one column: observed value
    # time is generated by the algorithm; integer for interpolation nodes
    if data_type == 'tides':
        IN = open(".data/tides_Dublin.txt","r")
        table = IN.readlines()
        IN.close()

        temp={}
        t = 0
        # t/t_unit is an integer every t_unit observations (node)
        t_unit = 16 # use 16 for ocean tides, 32 for planet data discussed in the classroom
        for string in table:
            string = string.replace('\n', '')
            fields = string.split('\t')
            temp[t/t_unit] = float(fields[0])
            t = t + 1
    elif data_type.startswith('planets'):
        # t/t_unit is an integer every t_unit observations (node)
        t_unit = 32  # use 16 for ocean tides, 32 for planet data discussed in the classroom
        anchor_planet = 'earth'
        if data_type == 'planets':
            other_planet = 'venue'
            orbital_radius_km_planet_1 = planet_data[anchor_planet]['orbital_radius_km']
            orbital_radius_km_planet_2 = planet_data[other_planet]['orbital_radius_km']
            orbital_period_days_planet_1 = planet_data[anchor_planet]['orbital_period_days']
            orbital_period_days_planet_2 = planet_data[other_planet]['orbital_period_days']

            num_years = 10

            planets_df = generate_distances_for_years(num_years,
                                              orbital_radius_km_planet_1,
                                              orbital_radius_km_planet_2,
                                              orbital_period_days_planet_1,
                                              orbital_period_days_planet_2)
            planets_df['t_unit'] = planets_df['time_since_start']/t_unit
            temp = planets_df[['t_unit','interplanetary_distance']].set_index('t_unit').to_dict()['interplanetary_distance']
        else:
            anchor_planet = 'earth'
            other_planets = [p for p in planet_data.keys()
                             if p != anchor_planet]

            planet_config = {
                'anchor_planet': anchor_planet,
                'other_planets': other_planets
            }
            num_years = 20
            g_t_df = generate_3_planet_distances_for_years(num_years,
                                                           planet_config)
            g_t_df['t_unit'] = g_t_df['time_since_start']/t_unit
            temp = g_t_df[['t_unit',
                           'sum_other_planets_2_earth']].set_index('t_unit').to_dict()['sum_other_planets_2_earth']


    nobs = len(temp)
else:
    t_unit = 16

#--- function to interpolate

def g(t):
    if mode == 'Data':
        z = temp[t]
    elif mode == 'Math.Bessel':
        t = 40*(t-t_min)/(t_max-t_min)
        z = mpmath.besselj(1,t)
        z = float(z.real) # real part of the complex-valued function
    elif mode == 'Math.Zeta':
        t = 4 + 40*(t-t_min)/(t_max-t_min)
        z = mpmath.zeta(complex(0.5,t))
        z = float(z.real) # real part of the complex-valued function
    return(z)

#--- interpolation function

def interpolate(t, eps):
    sum = 0
    t_0 = int(t + 0.5) # closest interpolation node to t
    pi2 = 2/np.pi
    flag1 = -1
    flag2 = -1
    for k in range(0, n):
        # use nodes k1, k2 in interpolation formula
        k1 = t_0 + k
        k2 = t_0 - k
        tt = t - t_0
        if k != 0:
            if k %2 == 0:
                z = g(k1) + g(k2)
                if abs(tt**2 - k**2) > eps:
                    term = flag1 * tt*z*pi2 * np.sin(tt/pi2) / (tt**2 - k**2)
                else:
                    # use limit as tt --> k
                    term = z/2
                flag1 = -flag1
            else:
                z = g(k1) - g(k2)
                if abs(tt**2 - k**2) > eps:
                    term = flag2 * tt*z*pi2 * np.cos(tt/pi2) / (tt**2 - k**2)
                else:
                    # use limit as tt --> k
                    term = z/2
                flag2 = -flag2
        else:
            z = g(k1)
            if abs(tt) > eps:
                term = z*pi2*np.sin(tt/pi2) / tt
            else:
                # use limit as tt --> k (here k = 0)
                term = z
        sum += term
    return(sum)

#--- main loop and visualizations

n  = 16
    # 2n+1 is number of nodes used in interpolation
    # in all 3 cases tested (data, math functions), n >= 8 works
if mode=='Data':
    # restrictions:
    #     t_min >= n, t_max  <= int(nobs/t_unit - n)
    #     t_max > t_min, at least one node between t_min and t_max
    t_min  = n  # interpolate between t_min and t_max
    t_max  = int(nobs/t_unit - n)  # must have t_max - t_min > 0
else:
    t_min = 0
    t_max = 100

incr   = 1/t_unit   # time increment between nodes
eps    = 1.0e-12

if data_type == 'types':
    OUT = open(".data/interpol_tides_Dublin.txt","w")
elif data_type == 'planets':
    OUT = open(f".data/interpol_planets_venus_earth_n-{n}_tunit-{t_unit}.txt", "w")
elif data_type == 'planets_3_body':
    OUT = open(f".data/interpol_other_planets_vs_earth_n-{n}_tunit-{t_unit}.txt", "w")
else:
    print('Not implemented')

time = []
ze = []
zi = []

fig = plt.figure(figsize=(6,3))
mpl.rcParams['axes.linewidth'] = 0.2
mpl.rc('xtick', labelsize=6)
mpl.rc('ytick', labelsize=6)

for t in np.arange(t_min, t_max, incr):
    time.append(t)
    z_interpol = interpolate(t, eps)
    z_exact = g(t)
    zi.append(z_interpol)
    ze.append(z_exact)
    error = abs(z_exact - z_interpol)
    if t == int(t):
        plt.scatter(t,z_exact,color='orange', s=6)
    print("t = %8.5f exact = %8.5f interpolated = %8.5f error = %8.5f %3d nodes" % (t,z_exact,z_interpol,error,n))
    OUT.write("%10.6f\t%10.6f\t%10.6f\t%10.6f\n" % (t,z_exact,z_interpol,error))
OUT.close()

plt.plot(time,ze,color='red',linewidth = 0.5, alpha=0.5)
plt.plot(time,zi,color='blue', linewidth = 0.5,alpha=0.5)
base = min(ze) - (max(ze) -min(ze))/10
for index in range(len(time)):
    # plot error bars showing delta between exact and interpolated values
    t = time[index]
    error = abs(zi[index]-ze[index])
    plt.vlines(t,base,base+error,color='black',linewidth=0.2)
if data_type == 'tides':
    plt.savefig('.data/tides2.png', dpi=200)
elif data_type == 'planets':
    plt.savefig(f'.data/planets_venus_earth_n-{n}_tunit-{t_unit}.png', dpi=200)
elif data_type == 'planets_3_body':
    plt.savefig(f'.data/other_planets_vs_earth_n-{n}_tunit-{t_unit}.png', dpi=200)
else:
    print("Not Implemented")
plt.show()